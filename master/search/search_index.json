{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Traefik Mesh: Simpler Service Mesh \u00b6 Traefik Mesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Traefik Mesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Traefik Mesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh. Non-Invasive Service Mesh \u00b6 Traefik Mesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Traefik Mesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Traefik Mesh does not modify your Kubernetes objects and does not modify your traffic without your knowledge. Using the Traefik Mesh endpoints is all that is required. Prerequisites \u00b6 To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Welcome"},{"location":"#traefik-mesh-simpler-service-mesh","text":"Traefik Mesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Traefik Mesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Traefik Mesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.","title":"Traefik Mesh: Simpler Service Mesh"},{"location":"#non-invasive-service-mesh","text":"Traefik Mesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Traefik Mesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Traefik Mesh does not modify your Kubernetes objects and does not modify your traffic without your knowledge. Using the Traefik Mesh endpoints is all that is required.","title":"Non-Invasive Service Mesh"},{"location":"#prerequisites","text":"To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Prerequisites"},{"location":"api/","text":"API \u00b6 Traefik Mesh includes a built-in API that can be used for debugging purposes. This can be useful when Traefik Mesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths: /api/configuration/current \u00b6 This endpoint provides raw json of the current configuration built by the controller. Note This may change on each request, as it is a live data structure. /api/status/nodes \u00b6 This endpoint provides a json array containing some details about the readiness of the Traefik Mesh nodes visible by the controller. This endpoint will still return a 200 if there are no visible nodes. /api/status/node/{traefik-mesh-pod-name}/configuration \u00b6 This endpoint provides raw json of the current configuration on the Traefik Mesh node with the pod name given in {traefik-mesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller. /api/status/readiness \u00b6 This endpoint returns a 200 response if the controller has successfully started. Otherwise, it will return a 500.","title":"API"},{"location":"api/#api","text":"Traefik Mesh includes a built-in API that can be used for debugging purposes. This can be useful when Traefik Mesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths:","title":"API"},{"location":"api/#apiconfigurationcurrent","text":"This endpoint provides raw json of the current configuration built by the controller. Note This may change on each request, as it is a live data structure.","title":"/api/configuration/current"},{"location":"api/#apistatusnodes","text":"This endpoint provides a json array containing some details about the readiness of the Traefik Mesh nodes visible by the controller. This endpoint will still return a 200 if there are no visible nodes.","title":"/api/status/nodes"},{"location":"api/#apistatusnodetraefik-mesh-pod-nameconfiguration","text":"This endpoint provides raw json of the current configuration on the Traefik Mesh node with the pod name given in {traefik-mesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller.","title":"/api/status/node/{traefik-mesh-pod-name}/configuration"},{"location":"api/#apistatusreadiness","text":"This endpoint returns a 200 response if the controller has successfully started. Otherwise, it will return a 500.","title":"/api/status/readiness"},{"location":"compatibility/","text":"Compatibility \u00b6 Traefik Mesh supports, similar to Kubernetes , at least the latest three minor versions of Kubernetes, therefore currently: 1.17 1.18 1.19 General functionality cannot be guaranted for versions older than that. However, we expect it to work with Kubernetes down to 1.11 currently. Compatibility by Features \u00b6 Some of Traefik Mesh's features are only supported on certain Kubernetes versions. Please see the table below. Features K8s 1.17 K8s 1.18 K8s 1.19 General functionality \u2714 \u2714 \u2714 Service Topology \u2714 \u2714 \u2714","title":"Compatibility"},{"location":"compatibility/#compatibility","text":"Traefik Mesh supports, similar to Kubernetes , at least the latest three minor versions of Kubernetes, therefore currently: 1.17 1.18 1.19 General functionality cannot be guaranted for versions older than that. However, we expect it to work with Kubernetes down to 1.11 currently.","title":"Compatibility"},{"location":"compatibility/#compatibility-by-features","text":"Some of Traefik Mesh's features are only supported on certain Kubernetes versions. Please see the table below. Features K8s 1.17 K8s 1.18 K8s 1.19 General functionality \u2714 \u2714 \u2714 Service Topology \u2714 \u2714 \u2714","title":"Compatibility by Features"},{"location":"configuration/","text":"Configuration \u00b6 The configuration for Traefik Mesh is broken down into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the service mesh is installed and is configured via the values.yaml file in the Helm install. Static configuration \u00b6 The controller image version as well as the Traefik image version used by mesh proxies can be manually defined if needed. Logging level and format for the controller and proxies can be defined. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Access-Control List (ACL) mode can be enabled. This configures Traefik Mesh to run in ACL mode, where all traffic is forbidden unless explicitly allowed via an SMI TrafficTarget . Please see the SMI Specification for more information. Dynamic configuration \u00b6 Dynamic configuration can be provided to Traefik Mesh using annotations on Kubernetes services and via SMI objects. Features ACL disabled ACL enabled Traffic-Type \u2714 \u2714 Scheme \u2714 \u2714 Retry \u2714 \u2714 Circuit-Breaker \u2714 \u2714 Rate-Limit \u2714 \u2714 Traffic-Split (SMI) \u2714 \u2714 Traffic-Target (SMI) \u2718 \u2714 Kubernetes Service Annotations \u00b6 Annotations on services give the ability to configure how Traefik Mesh interprets them. Traffic type \u00b6 The traffic type can be configured by using the following annotation: mesh.traefik.io/traffic-type: \"http\" This annotation can be set to either http , tcp or udp and will specifies the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration. Info For now, the udp traffic type does not work when ACL mode is enabled. In ACL mode, all traffic is forbidden unless it is explicitly allowed with a TrafficTarget and unfortunately the SMI specification does not yet define a Traffic Spec for UDP . Scheme \u00b6 The scheme used to define custom scheme for request: mesh.traefik.io/scheme: \"h2c\" This annotation can be set to either http , https or h2c and is available for mesh.traefik.io/traffic-type: \"http\" . Limitations Please keep in mind, that if you set the scheme to https your service needs to expose itself via HTTPS as there is no mTLS in Traefik Mesh. Retry \u00b6 Retries can be enabled by using the following annotation: mesh.traefik.io/retry-attempts: \"2\" This annotation sets the number of retry attempts that Traefik Mesh will make if a network error occurs. Please note that this value is a string, and needs to be quoted. Circuit breaker \u00b6 Circuit breaker can be enabled by using the following annotation: mesh.traefik.io/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here . Rate Limit \u00b6 Rate limiting can be enabled by using the following annotations: mesh.traefik.io/ratelimit-average: \"100\" mesh.traefik.io/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here . Service Mesh Interface \u00b6 Access Control \u00b6 The first step is to describe what the traffic of our server application looks like. --- apiVersion: specs.smi-spec.io/v1alpha3 kind: HTTPRouteGroup metadata: name: server-routes namespace: server spec: matches: - name: api pathRegex: /api methods: [\"*\"] - name: metrics pathRegex: /metrics methods: [\"GET\"] In this example, we define a set of HTTP routes for our server application. More precisely, the server app is composed by two routes: The api route under the /api path, accepting all methods. The metrics routes under the /metrics path, accepting only GET requests. Other types of route groups and detailed information are available in the SMI specification . By default, all traffic is denied so we need to grant access to clients to our application. This is done by defining a TrafficTarget . TrafficTarget Source & Destination Please note that TrafficTarget is a namespaced resource. If the destination namespace is not populated, the TrafficTarget namespace will be used as the destination namespace. The source namespace must be populated, as it cannot be inferred. --- apiVersion: access.smi-spec.io/v1alpha2 kind: TrafficTarget metadata: name: client-server-target namespace: server spec: destination: kind: ServiceAccount name: server namespace: server rules: - kind: HTTPRouteGroup name: server-routes matches: - api sources: - kind: ServiceAccount name: client namespace: client In this example, we grant access to all pods running with the service account client under the namespace client to the HTTP route api specified by on the group server-routes on all pods running with the service account server under the namespace server . Any client running with the service account client under the client namespace accessing server.server.traefik.mesh/api is allowed to access the /api resource. Others will receive 404 answers from the Traefik Mesh node. More information can be found in the SMI specification . Traffic Splitting \u00b6 SMI defines the TrafficSplit resource which allows to direct subsets of the traffic to different services. apiVersion: split.smi-spec.io/v1alpha3 kind: TrafficSplit metadata: name: server-split namespace: server spec: service: server backends: - service: server-v1 weight: 80 - service: server-v2 weight: 20 In this example, we define a traffic split for our server service between two versions of our server, v1 and v2. server.server.traefik.mesh directs 80% of the traffic to the server-v1 pods, and 20% of the traffic to the server-v2 pods. More information can be found in the SMI specification . Traffic Metrics \u00b6 At the moment, Traefik Mesh does not implement the Traffic Metrics specification .","title":"Configuration"},{"location":"configuration/#configuration","text":"The configuration for Traefik Mesh is broken down into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the service mesh is installed and is configured via the values.yaml file in the Helm install.","title":"Configuration"},{"location":"configuration/#static-configuration","text":"The controller image version as well as the Traefik image version used by mesh proxies can be manually defined if needed. Logging level and format for the controller and proxies can be defined. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Access-Control List (ACL) mode can be enabled. This configures Traefik Mesh to run in ACL mode, where all traffic is forbidden unless explicitly allowed via an SMI TrafficTarget . Please see the SMI Specification for more information.","title":"Static configuration"},{"location":"configuration/#dynamic-configuration","text":"Dynamic configuration can be provided to Traefik Mesh using annotations on Kubernetes services and via SMI objects. Features ACL disabled ACL enabled Traffic-Type \u2714 \u2714 Scheme \u2714 \u2714 Retry \u2714 \u2714 Circuit-Breaker \u2714 \u2714 Rate-Limit \u2714 \u2714 Traffic-Split (SMI) \u2714 \u2714 Traffic-Target (SMI) \u2718 \u2714","title":"Dynamic configuration"},{"location":"configuration/#kubernetes-service-annotations","text":"Annotations on services give the ability to configure how Traefik Mesh interprets them.","title":"Kubernetes Service Annotations"},{"location":"configuration/#traffic-type","text":"The traffic type can be configured by using the following annotation: mesh.traefik.io/traffic-type: \"http\" This annotation can be set to either http , tcp or udp and will specifies the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration. Info For now, the udp traffic type does not work when ACL mode is enabled. In ACL mode, all traffic is forbidden unless it is explicitly allowed with a TrafficTarget and unfortunately the SMI specification does not yet define a Traffic Spec for UDP .","title":"Traffic type"},{"location":"configuration/#scheme","text":"The scheme used to define custom scheme for request: mesh.traefik.io/scheme: \"h2c\" This annotation can be set to either http , https or h2c and is available for mesh.traefik.io/traffic-type: \"http\" . Limitations Please keep in mind, that if you set the scheme to https your service needs to expose itself via HTTPS as there is no mTLS in Traefik Mesh.","title":"Scheme"},{"location":"configuration/#retry","text":"Retries can be enabled by using the following annotation: mesh.traefik.io/retry-attempts: \"2\" This annotation sets the number of retry attempts that Traefik Mesh will make if a network error occurs. Please note that this value is a string, and needs to be quoted.","title":"Retry"},{"location":"configuration/#circuit-breaker","text":"Circuit breaker can be enabled by using the following annotation: mesh.traefik.io/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here .","title":"Circuit breaker"},{"location":"configuration/#rate-limit","text":"Rate limiting can be enabled by using the following annotations: mesh.traefik.io/ratelimit-average: \"100\" mesh.traefik.io/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here .","title":"Rate Limit"},{"location":"configuration/#service-mesh-interface","text":"","title":"Service Mesh Interface"},{"location":"configuration/#access-control","text":"The first step is to describe what the traffic of our server application looks like. --- apiVersion: specs.smi-spec.io/v1alpha3 kind: HTTPRouteGroup metadata: name: server-routes namespace: server spec: matches: - name: api pathRegex: /api methods: [\"*\"] - name: metrics pathRegex: /metrics methods: [\"GET\"] In this example, we define a set of HTTP routes for our server application. More precisely, the server app is composed by two routes: The api route under the /api path, accepting all methods. The metrics routes under the /metrics path, accepting only GET requests. Other types of route groups and detailed information are available in the SMI specification . By default, all traffic is denied so we need to grant access to clients to our application. This is done by defining a TrafficTarget . TrafficTarget Source & Destination Please note that TrafficTarget is a namespaced resource. If the destination namespace is not populated, the TrafficTarget namespace will be used as the destination namespace. The source namespace must be populated, as it cannot be inferred. --- apiVersion: access.smi-spec.io/v1alpha2 kind: TrafficTarget metadata: name: client-server-target namespace: server spec: destination: kind: ServiceAccount name: server namespace: server rules: - kind: HTTPRouteGroup name: server-routes matches: - api sources: - kind: ServiceAccount name: client namespace: client In this example, we grant access to all pods running with the service account client under the namespace client to the HTTP route api specified by on the group server-routes on all pods running with the service account server under the namespace server . Any client running with the service account client under the client namespace accessing server.server.traefik.mesh/api is allowed to access the /api resource. Others will receive 404 answers from the Traefik Mesh node. More information can be found in the SMI specification .","title":"Access Control"},{"location":"configuration/#traffic-splitting","text":"SMI defines the TrafficSplit resource which allows to direct subsets of the traffic to different services. apiVersion: split.smi-spec.io/v1alpha3 kind: TrafficSplit metadata: name: server-split namespace: server spec: service: server backends: - service: server-v1 weight: 80 - service: server-v2 weight: 20 In this example, we define a traffic split for our server service between two versions of our server, v1 and v2. server.server.traefik.mesh directs 80% of the traffic to the server-v1 pods, and 20% of the traffic to the server-v2 pods. More information can be found in the SMI specification .","title":"Traffic Splitting"},{"location":"configuration/#traffic-metrics","text":"At the moment, Traefik Mesh does not implement the Traffic Metrics specification .","title":"Traffic Metrics"},{"location":"examples/","text":"Examples \u00b6 Here are some examples on how to easily deploy Traefik Mesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Traefik Mesh . Simple Example \u00b6 Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: traefik/whoami:v1.6.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: traefik/whoamitcp:v0.1.0 imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Traefik Mesh by following this documentation on your cluster. Since Traefik Mesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Traefik Mesh since no X-Forwarded-For header should be added. Now, in order to configure Traefik Mesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have mesh.traefik.io/traffic-type: \"http\" and the TCP service, mesh.traefik.io/traffic-type: \"tcp\" . --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami annotations: mesh.traefik.io/traffic-type: \"http\" mesh.traefik.io/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp annotations: mesh.traefik.io/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Traefik Mesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.traefik.mesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.traefik.mesh User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6 ACL Example \u00b6 The ACL mode can be enabled when installing Traefik Mesh. Once activated, all traffic is forbidden unless explicitly authorized using the SMI TrafficTarget resource. This example will present the configuration required to allow the client pod to send traffic to the HTTP and TCP services defined in the previous example. Each TrafficTarget defines that a set of source ServiceAccount is capable of sending traffic to a destination ServiceAccount . To authorize the whoami-client pod to send traffic to whoami.whoami.traefik.mesh , we need to explicitly allow it to hit the pods exposed by the whoami service. --- apiVersion: specs.smi-spec.io/v1alpha3 kind: HTTPRouteGroup metadata: name: http-everything namespace: whoami spec: matches: - name: everything pathRegex: \".*\" methods: [\"*\"] --- kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha2 metadata: name: whatever namespace: whoami spec: destination: kind: ServiceAccount name: whoami-server namespace: whoami port: \"80\" rules: - kind: HTTPRouteGroup name: http-everything matches: - everything sources: - kind: ServiceAccount name: whoami-client namespace: whoami Incoming traffic on a TCP service can also be authorized using a TrafficTarget and a TCPRoute . --- kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha2 metadata: name: api-service-target namespace: default spec: destination: kind: ServiceAccount name: api-service namespace: default rules: - kind: TCPRoute name: my-tcp-route sources: - kind: ServiceAccount name: my-other-service namespace: default --- apiVersion: specs.smi-spec.io/v1alpha3 kind: TCPRoute metadata: name: my-tcp-route spec: {}","title":"Examples"},{"location":"examples/#examples","text":"Here are some examples on how to easily deploy Traefik Mesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Traefik Mesh .","title":"Examples"},{"location":"examples/#simple-example","text":"Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: traefik/whoami:v1.6.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: traefik/whoamitcp:v0.1.0 imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Traefik Mesh by following this documentation on your cluster. Since Traefik Mesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Traefik Mesh since no X-Forwarded-For header should be added. Now, in order to configure Traefik Mesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have mesh.traefik.io/traffic-type: \"http\" and the TCP service, mesh.traefik.io/traffic-type: \"tcp\" . --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami annotations: mesh.traefik.io/traffic-type: \"http\" mesh.traefik.io/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp annotations: mesh.traefik.io/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Traefik Mesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.traefik.mesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.traefik.mesh User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6","title":"Simple Example"},{"location":"examples/#acl-example","text":"The ACL mode can be enabled when installing Traefik Mesh. Once activated, all traffic is forbidden unless explicitly authorized using the SMI TrafficTarget resource. This example will present the configuration required to allow the client pod to send traffic to the HTTP and TCP services defined in the previous example. Each TrafficTarget defines that a set of source ServiceAccount is capable of sending traffic to a destination ServiceAccount . To authorize the whoami-client pod to send traffic to whoami.whoami.traefik.mesh , we need to explicitly allow it to hit the pods exposed by the whoami service. --- apiVersion: specs.smi-spec.io/v1alpha3 kind: HTTPRouteGroup metadata: name: http-everything namespace: whoami spec: matches: - name: everything pathRegex: \".*\" methods: [\"*\"] --- kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha2 metadata: name: whatever namespace: whoami spec: destination: kind: ServiceAccount name: whoami-server namespace: whoami port: \"80\" rules: - kind: HTTPRouteGroup name: http-everything matches: - everything sources: - kind: ServiceAccount name: whoami-client namespace: whoami Incoming traffic on a TCP service can also be authorized using a TrafficTarget and a TCPRoute . --- kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha2 metadata: name: api-service-target namespace: default spec: destination: kind: ServiceAccount name: api-service namespace: default rules: - kind: TCPRoute name: my-tcp-route sources: - kind: ServiceAccount name: my-other-service namespace: default --- apiVersion: specs.smi-spec.io/v1alpha3 kind: TCPRoute metadata: name: my-tcp-route spec: {}","title":"ACL Example"},{"location":"install/","text":"Installation \u00b6 To install Traefik Mesh, the installation method is quite simple: helm repo add traefik-mesh https://traefik.github.io/mesh/charts helm repo update Install Traefik Mesh Helm Chart: helm install traefik-mesh traefik-mesh/traefik-mesh Install from source \u00b6 Supported Installations Please be aware that the supported installation method is via Helm, using official releases. If you want to build/install/run Traefik Mesh from source, we may not be able to provide support. Installing from source is intended for development/contributing. To build the image locally, run: make You will then be able to use the tagged image as your image in your values.yaml file. Deploy Helm Chart \u00b6 To deploy the Helm Chart, run: helm install traefik-mesh helm/chart/mesh --set controller.image.pullPolicy=IfNotPresent --set controller.image.tag=latest KubeDNS support \u00b6 Traefik Mesh supports KubeDNS: helm install traefik-mesh traefik-mesh/traefik-mesh --set kubedns=true With the kubedns parameter Traefik Mesh will install CoreDNS and patch KubeDNS to use it as a stubDomain . Custom cluster domain \u00b6 If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install traefik-mesh traefik-mesh/traefik-mesh --set clusterDomain=my.custom.domain.com Access Control List \u00b6 By default, Traefik Mesh does not restrict traffic between pods and services. However, some scenarios require more control over the rules for internal communication. The Access Control List mode (ACL) requires a set of rules to explicitly allow traffic between different resources. To enable ACL, install Traefik Mesh in ACL mode by setting the acl Helm Chart option to true . helm install traefik-mesh --namespace=traefik-mesh traefik-mesh/traefik-mesh --set acl=true Traefik Mesh supports the SMI specification which defines a set of custom resources to provide a fine-grained control over instrumentation, routing and access control of east-west communications. CRDs Helm v3 will install automatically the CRDs in the /crds directory. If you are (re)installing into a cluster with the CRDs already present, Helm may print a warning. If you do not want to install them, or want to avoid the warning, use the new --skip-crds flag. More information can be found in the Helm documentation . Platform recommendations \u00b6 Traefik Mesh works on Kubernetes environments that conforms to the global Kubernetes specification. That being said, we have had users encounter issues when using variants such as minikube, microk8s, and other development distributions. Traefik Mesh runs without issue on most public clouds (AWS, GKE, Azure, DigitalOcean, and more). If you want to run Traefik Mesh in development, we would recommend using k3s , as it is fully conformant. We use k3s in Traefik Mesh's integration tests, so you can be sure that it works properly. If you encounter issues on variants such as minikube or microk8s, please try and reproduce the issue on k3s. If you are unable to reproduce, it may be an issue with the distribution behaving differently than official Kubernetes. Verify your installation \u00b6 You can check that Traefik Mesh has been installed properly by running the following command: Command kubectl get all -n traefik-mesh Expected Output NAME READY STATUS RESTARTS AGE pod/traefik-mesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/traefik-mesh-proxy-w62z5 1/1 Running 0 11s pod/traefik-mesh-proxy-zjlpf 1/1 Running 0 11s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/traefik-mesh-proxy 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/traefik-mesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/traefik-mesh-controller-676fb86b89 1 1 0 28s Usage \u00b6 To use Traefik Mesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.traefik.mesh . This will access the Traefik Mesh service mesh, and will allow you to route requests through Traefik Mesh. By default, Traefik Mesh is opt-in, meaning you have to use the Traefik Mesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Installation"},{"location":"install/#installation","text":"To install Traefik Mesh, the installation method is quite simple: helm repo add traefik-mesh https://traefik.github.io/mesh/charts helm repo update Install Traefik Mesh Helm Chart: helm install traefik-mesh traefik-mesh/traefik-mesh","title":"Installation"},{"location":"install/#install-from-source","text":"Supported Installations Please be aware that the supported installation method is via Helm, using official releases. If you want to build/install/run Traefik Mesh from source, we may not be able to provide support. Installing from source is intended for development/contributing. To build the image locally, run: make You will then be able to use the tagged image as your image in your values.yaml file.","title":"Install from source"},{"location":"install/#deploy-helm-chart","text":"To deploy the Helm Chart, run: helm install traefik-mesh helm/chart/mesh --set controller.image.pullPolicy=IfNotPresent --set controller.image.tag=latest","title":"Deploy Helm Chart"},{"location":"install/#kubedns-support","text":"Traefik Mesh supports KubeDNS: helm install traefik-mesh traefik-mesh/traefik-mesh --set kubedns=true With the kubedns parameter Traefik Mesh will install CoreDNS and patch KubeDNS to use it as a stubDomain .","title":"KubeDNS support"},{"location":"install/#custom-cluster-domain","text":"If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install traefik-mesh traefik-mesh/traefik-mesh --set clusterDomain=my.custom.domain.com","title":"Custom cluster domain"},{"location":"install/#access-control-list","text":"By default, Traefik Mesh does not restrict traffic between pods and services. However, some scenarios require more control over the rules for internal communication. The Access Control List mode (ACL) requires a set of rules to explicitly allow traffic between different resources. To enable ACL, install Traefik Mesh in ACL mode by setting the acl Helm Chart option to true . helm install traefik-mesh --namespace=traefik-mesh traefik-mesh/traefik-mesh --set acl=true Traefik Mesh supports the SMI specification which defines a set of custom resources to provide a fine-grained control over instrumentation, routing and access control of east-west communications. CRDs Helm v3 will install automatically the CRDs in the /crds directory. If you are (re)installing into a cluster with the CRDs already present, Helm may print a warning. If you do not want to install them, or want to avoid the warning, use the new --skip-crds flag. More information can be found in the Helm documentation .","title":"Access Control List"},{"location":"install/#platform-recommendations","text":"Traefik Mesh works on Kubernetes environments that conforms to the global Kubernetes specification. That being said, we have had users encounter issues when using variants such as minikube, microk8s, and other development distributions. Traefik Mesh runs without issue on most public clouds (AWS, GKE, Azure, DigitalOcean, and more). If you want to run Traefik Mesh in development, we would recommend using k3s , as it is fully conformant. We use k3s in Traefik Mesh's integration tests, so you can be sure that it works properly. If you encounter issues on variants such as minikube or microk8s, please try and reproduce the issue on k3s. If you are unable to reproduce, it may be an issue with the distribution behaving differently than official Kubernetes.","title":"Platform recommendations"},{"location":"install/#verify-your-installation","text":"You can check that Traefik Mesh has been installed properly by running the following command: Command kubectl get all -n traefik-mesh Expected Output NAME READY STATUS RESTARTS AGE pod/traefik-mesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/traefik-mesh-proxy-w62z5 1/1 Running 0 11s pod/traefik-mesh-proxy-zjlpf 1/1 Running 0 11s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/traefik-mesh-proxy 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/traefik-mesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/traefik-mesh-controller-676fb86b89 1 1 0 28s","title":"Verify your installation"},{"location":"install/#usage","text":"To use Traefik Mesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.traefik.mesh . This will access the Traefik Mesh service mesh, and will allow you to route requests through Traefik Mesh. By default, Traefik Mesh is opt-in, meaning you have to use the Traefik Mesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Usage"},{"location":"quickstart/","text":"Quickstart \u00b6 Traefik Mesh can be installed in your cluster without affecting any running services. It can safely be installed using the Helm Chart . Prerequisites \u00b6 Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3 RBAC \u00b6 Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions. kubeadm \u00b6 If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system Installing Traefik Mesh \u00b6 Command helm repo add traefik-mesh https://traefik.github.io/mesh/charts helm repo update helm install traefik-mesh traefik-mesh/traefik-mesh Expected output [...] NOTES: Thank you for installing traefik-mesh. Your release is named traefik-mesh. To learn more about the release, try: $ helm status traefik-mesh $ helm get traefik-mesh Using Traefik Mesh \u00b6 As an example, let's deploy a server application and a client application under the test namespace. server.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: server namespace: test labels: app: server spec: replicas: 2 selector: matchLabels: app: server template: metadata: labels: app: server spec: containers: - name: server image: traefik/whoami:v1.6.0 ports: - containerPort: 80 --- kind: Service apiVersion: v1 metadata: name: server namespace: test spec: selector: app: server ports: - name: web protocol: TCP port: 80 targetPort: 80 client.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: client namespace: test labels: app: client spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: giantswarm/tiny-tools:3.9 imagePullPolicy: IfNotPresent command: - \"sleep\" - \"infinity\" Create the namespace then deploy those two applications: kubectl create namespace test kubectl apply -f server.yaml kubectl apply -f client.yaml You should now see the following output: Command kubectl get all -n test Expected output NAME READY STATUS RESTARTS AGE pod/client-7446fdf848-x96fq 1/1 Running 0 79s pod/server-7c8fd58db5-rchg8 1/1 Running 0 77s pod/server-7c8fd58db5-sd4f9 1/1 Running 0 77s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/server ClusterIP 10.43.17.247 <none> 80/TCP 77s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/client 1/1 1 1 79s deployment.apps/server 2/2 2 2 77s NAME DESIRED CURRENT READY AGE replicaset.apps/client-7446fdf848 1 1 1 79s replicaset.apps/server-7c8fd58db5 2 2 2 77s Take note of the client app pod name (here it's client-7446fdf848-x96fq ) and open a new terminal session inside this pod using kubectl exec . kubectl -n test exec -ti client-7446fdf848-x96fq ash From inside the client container, make sure your server is reachable using the Kubernetes DNS service discovery. Command curl server.test.svc.cluster.local Expected Output Hostname: server-7c8fd58db5-sd4f9 IP: 127.0.0.1 IP: ::1 IP: 10.42.2.10 IP: fe80::a4ec:77ff:fe37:1cdd RemoteAddr: 10.42.2.9:46078 GET / HTTP/1.1 Host: server.test.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* You can note that all this server application is doing is to respond with the content of the request it receives. Now replace the svc.cluster.local suffix by traefik.mesh , and tada: you are now using Traefik Mesh to reach your server! Command curl server.test.traefik.mesh Expected Output Hostname: server-7c8fd58db5-rchg8 IP: 127.0.0.1 IP: ::1 IP: 10.42.1.7 IP: fe80::601d:7cff:fe26:c8c6 RemoteAddr: 10.42.1.5:59478 GET / HTTP/1.1 Host: server.test.traefik.mesh User-Agent: curl/7.64.0 Accept: */* Accept-Encoding: gzip Uber-Trace-Id: 3f9e7129a059f70:7e889a1ebcb147ac:3f9e7129a059f70:1 X-Forwarded-For: 10.42.2.9 X-Forwarded-Host: server.test.traefik.mesh X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: traefik-mesh-proxy-w95q2 X-Real-Ip: 10.42.2.9 Note the presence of X-Forwarded headers as well as other instrumentation headers like Uber-Trace-Id , indicating than your request has been processed and instrumented by Traefik Mesh. What's next \u00b6 See the examples page to see a more advanced example, or dive into the configuration to discover all Traefik Mesh capabilities.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Traefik Mesh can be installed in your cluster without affecting any running services. It can safely be installed using the Helm Chart .","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Prerequisites"},{"location":"quickstart/#rbac","text":"Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions.","title":"RBAC"},{"location":"quickstart/#kubeadm","text":"If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system","title":"kubeadm"},{"location":"quickstart/#installing-traefik-mesh","text":"Command helm repo add traefik-mesh https://traefik.github.io/mesh/charts helm repo update helm install traefik-mesh traefik-mesh/traefik-mesh Expected output [...] NOTES: Thank you for installing traefik-mesh. Your release is named traefik-mesh. To learn more about the release, try: $ helm status traefik-mesh $ helm get traefik-mesh","title":"Installing Traefik Mesh"},{"location":"quickstart/#using-traefik-mesh","text":"As an example, let's deploy a server application and a client application under the test namespace. server.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: server namespace: test labels: app: server spec: replicas: 2 selector: matchLabels: app: server template: metadata: labels: app: server spec: containers: - name: server image: traefik/whoami:v1.6.0 ports: - containerPort: 80 --- kind: Service apiVersion: v1 metadata: name: server namespace: test spec: selector: app: server ports: - name: web protocol: TCP port: 80 targetPort: 80 client.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: client namespace: test labels: app: client spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: giantswarm/tiny-tools:3.9 imagePullPolicy: IfNotPresent command: - \"sleep\" - \"infinity\" Create the namespace then deploy those two applications: kubectl create namespace test kubectl apply -f server.yaml kubectl apply -f client.yaml You should now see the following output: Command kubectl get all -n test Expected output NAME READY STATUS RESTARTS AGE pod/client-7446fdf848-x96fq 1/1 Running 0 79s pod/server-7c8fd58db5-rchg8 1/1 Running 0 77s pod/server-7c8fd58db5-sd4f9 1/1 Running 0 77s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/server ClusterIP 10.43.17.247 <none> 80/TCP 77s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/client 1/1 1 1 79s deployment.apps/server 2/2 2 2 77s NAME DESIRED CURRENT READY AGE replicaset.apps/client-7446fdf848 1 1 1 79s replicaset.apps/server-7c8fd58db5 2 2 2 77s Take note of the client app pod name (here it's client-7446fdf848-x96fq ) and open a new terminal session inside this pod using kubectl exec . kubectl -n test exec -ti client-7446fdf848-x96fq ash From inside the client container, make sure your server is reachable using the Kubernetes DNS service discovery. Command curl server.test.svc.cluster.local Expected Output Hostname: server-7c8fd58db5-sd4f9 IP: 127.0.0.1 IP: ::1 IP: 10.42.2.10 IP: fe80::a4ec:77ff:fe37:1cdd RemoteAddr: 10.42.2.9:46078 GET / HTTP/1.1 Host: server.test.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* You can note that all this server application is doing is to respond with the content of the request it receives. Now replace the svc.cluster.local suffix by traefik.mesh , and tada: you are now using Traefik Mesh to reach your server! Command curl server.test.traefik.mesh Expected Output Hostname: server-7c8fd58db5-rchg8 IP: 127.0.0.1 IP: ::1 IP: 10.42.1.7 IP: fe80::601d:7cff:fe26:c8c6 RemoteAddr: 10.42.1.5:59478 GET / HTTP/1.1 Host: server.test.traefik.mesh User-Agent: curl/7.64.0 Accept: */* Accept-Encoding: gzip Uber-Trace-Id: 3f9e7129a059f70:7e889a1ebcb147ac:3f9e7129a059f70:1 X-Forwarded-For: 10.42.2.9 X-Forwarded-Host: server.test.traefik.mesh X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: traefik-mesh-proxy-w95q2 X-Real-Ip: 10.42.2.9 Note the presence of X-Forwarded headers as well as other instrumentation headers like Uber-Trace-Id , indicating than your request has been processed and instrumented by Traefik Mesh.","title":"Using Traefik Mesh"},{"location":"quickstart/#whats-next","text":"See the examples page to see a more advanced example, or dive into the configuration to discover all Traefik Mesh capabilities.","title":"What's next"},{"location":"contributing/building-testing/","text":"Building and Testing \u00b6 So you want to build your own Traefik Mesh binary from the sources? Let's see how. Building \u00b6 To build Traefik Mesh from the sources you need either Docker and make , or Go . With Docker and make \u00b6 Traefik Mesh can be built from the sources by using the make command. This will create a binary for the Linux platform in the dist directory and a Docker image: $ make #[...] Successfully tagged traefik/mesh:latest docker run --name=build -t \"traefik/mesh:latest\" version version: version : b417901 commit : b417901 build date : 2020-09-01_09:27:55AM go version : go1.15 go compiler : gc platform : linux/amd64 #[...] $ ls dist/ traefik-mesh Note The default make target invokes the clean , check , test and build targets. With Go \u00b6 Requirements: Go v1.14+ Environment variable GO111MODULE=on One your Go environment is set up, you can build Traefik Mesh from the sources by using the go build command. The Go compiler will build an executable for your platform. $ go build -o dist/traefik-mesh cmd/mesh/mesh.go $ ./dist/traefik-mesh version version: version : dev commit : I don't remember exactly build date : I don't remember exactly go version : go1.15 go compiler : gc platform : linux/amd64 Testing \u00b6 With Docker and make \u00b6 Run unit tests by using the test target: $ make test docker build --tag \"traefik/mesh:test\" --target maker --build-arg=\"MAKE_TARGET=local-test\" /home/user/traefik-mesh/ #[...] --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.20s) PASS coverage: 69.7% of statements ok github.com/traefik/mesh/pkg/providers/smi 1.982s coverage: 69.7% of statements ? github.com/traefik/mesh/pkg/signals [no test files] Removing intermediate container 4e887c16ddee ---> 75d44229a46e Successfully built 75d44229a46e Successfully tagged traefik/mesh:test Run the integration tests by using the test-integration target. For development purposes, you can specify which tests to run by using the TESTFLAGS environment variable (only works with the test-integration target): # Run every tests in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More on https://labix.org/gocheck . With Go \u00b6 Run the unit tests by using the go test command: $ go test -v ./... #[...] === RUN TestGroupTrafficTargetsByDestination --- PASS: TestGroupTrafficTargetsByDestination (0.20s) === RUN TestBuildConfiguration === RUN TestBuildConfiguration/simple_configuration_build_with_HTTP_service === PAUSE TestBuildConfiguration/simple_configuration_build_with_HTTP_service === CONT TestBuildConfiguration/simple_configuration_build_with_HTTP_service time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found applicable traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found grouped traffictargets for service default/demo-service: map[{name:api-service namespace:default port:}:[0xc000900820]]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"No TrafficSplits in namespace: default\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found trafficsplits for service default/demo-service: []\" --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.21s) PASS ok github.com/traefik/mesh/pkg/providers/smi 3.634s ? github.com/traefik/mesh/pkg/signals [no test files] Run the integration tests in the integration directory by using the go test ./integration -integration command: $ go test -v ./integration -integration -check.f HelmSuite #[...] OK: 2 passed --- PASS: Test (161.20s) PASS ok github.com/traefik/mesh/integration 162.695s Important Before running the integration tests, build the Traefik Mesh Docker image. Check out the Building section for more details.","title":"Building and Testing"},{"location":"contributing/building-testing/#building-and-testing","text":"So you want to build your own Traefik Mesh binary from the sources? Let's see how.","title":"Building and Testing"},{"location":"contributing/building-testing/#building","text":"To build Traefik Mesh from the sources you need either Docker and make , or Go .","title":"Building"},{"location":"contributing/building-testing/#with-docker-and-make","text":"Traefik Mesh can be built from the sources by using the make command. This will create a binary for the Linux platform in the dist directory and a Docker image: $ make #[...] Successfully tagged traefik/mesh:latest docker run --name=build -t \"traefik/mesh:latest\" version version: version : b417901 commit : b417901 build date : 2020-09-01_09:27:55AM go version : go1.15 go compiler : gc platform : linux/amd64 #[...] $ ls dist/ traefik-mesh Note The default make target invokes the clean , check , test and build targets.","title":"With Docker and make"},{"location":"contributing/building-testing/#with-go","text":"Requirements: Go v1.14+ Environment variable GO111MODULE=on One your Go environment is set up, you can build Traefik Mesh from the sources by using the go build command. The Go compiler will build an executable for your platform. $ go build -o dist/traefik-mesh cmd/mesh/mesh.go $ ./dist/traefik-mesh version version: version : dev commit : I don't remember exactly build date : I don't remember exactly go version : go1.15 go compiler : gc platform : linux/amd64","title":"With Go"},{"location":"contributing/building-testing/#testing","text":"","title":"Testing"},{"location":"contributing/building-testing/#with-docker-and-make_1","text":"Run unit tests by using the test target: $ make test docker build --tag \"traefik/mesh:test\" --target maker --build-arg=\"MAKE_TARGET=local-test\" /home/user/traefik-mesh/ #[...] --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.20s) PASS coverage: 69.7% of statements ok github.com/traefik/mesh/pkg/providers/smi 1.982s coverage: 69.7% of statements ? github.com/traefik/mesh/pkg/signals [no test files] Removing intermediate container 4e887c16ddee ---> 75d44229a46e Successfully built 75d44229a46e Successfully tagged traefik/mesh:test Run the integration tests by using the test-integration target. For development purposes, you can specify which tests to run by using the TESTFLAGS environment variable (only works with the test-integration target): # Run every tests in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More on https://labix.org/gocheck .","title":"With Docker and make"},{"location":"contributing/building-testing/#with-go_1","text":"Run the unit tests by using the go test command: $ go test -v ./... #[...] === RUN TestGroupTrafficTargetsByDestination --- PASS: TestGroupTrafficTargetsByDestination (0.20s) === RUN TestBuildConfiguration === RUN TestBuildConfiguration/simple_configuration_build_with_HTTP_service === PAUSE TestBuildConfiguration/simple_configuration_build_with_HTTP_service === CONT TestBuildConfiguration/simple_configuration_build_with_HTTP_service time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found applicable traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found grouped traffictargets for service default/demo-service: map[{name:api-service namespace:default port:}:[0xc000900820]]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"No TrafficSplits in namespace: default\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found trafficsplits for service default/demo-service: []\" --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.21s) PASS ok github.com/traefik/mesh/pkg/providers/smi 3.634s ? github.com/traefik/mesh/pkg/signals [no test files] Run the integration tests in the integration directory by using the go test ./integration -integration command: $ go test -v ./integration -integration -check.f HelmSuite #[...] OK: 2 passed --- PASS: Test (161.20s) PASS ok github.com/traefik/mesh/integration 162.695s Important Before running the integration tests, build the Traefik Mesh Docker image. Check out the Building section for more details.","title":"With Go"},{"location":"contributing/documentation/","text":"Documentation \u00b6 You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how. Building \u00b6 This documentation is built with MkDocs . With Docker and make \u00b6 You can build the documentation and test it locally (with live reloading), using the serve target: $ make serve docker build -t traefik-mesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /home/user/traefik-mesh/docs:/mkdocs -p 8000:8000 traefik-mesh-docs mkdocs serve # [\u2026] INFO - Building documentation... INFO - Cleaning site directory [I 200408 14:36:33 server:296] Serving on http://0.0.0.0:8000 [I 200408 14:36:33 handlers:62] Start watching changes [I 200408 14:36:33 handlers:64] Start detecting changes Note By default, the local documentation server listens on http://127.0.0.1:8000 . To build the documentation without serving it locally, use the build target. With MkDocs \u00b6 First, make sure you have python and pip installed. MkDocs supports python versions 2.7.9+ , 3.4 , 3.5 , 3.6 and 3.7 . $ python --version Python 2.7.14 $ pip --version pip 19.3.1 from /usr/local/lib/python2.7/site-packages/pip (python 2.7) Then, install MkDocs with pip . pip install --user -r requirements.txt To build the documentation and serve it locally, run mkdocs serve from the root directory. This starts a local server, and exposes the documentation on http://127.0.0.1:8000 : $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes Checking \u00b6 To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the verify target. If you've made changes to the documentation, it's safer to clean it before verifying it. $ make clean verify docker build -t traefik-mesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /home/user/traefik-mesh/docs:/mkdocs -p 8000:8000 traefik-mesh-docs sh -c \"mkdocs build && chown -R 501:20 ./site\" === Checking HTML content... # [\u2026] Disabling Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : $ DOCS_VERIFY_SKIP=true make verify # [\u2026] DOCS_VERIFY_SKIP is true: no verification done.","title":"Documentation"},{"location":"contributing/documentation/#documentation","text":"You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how.","title":"Documentation"},{"location":"contributing/documentation/#building","text":"This documentation is built with MkDocs .","title":"Building"},{"location":"contributing/documentation/#with-docker-and-make","text":"You can build the documentation and test it locally (with live reloading), using the serve target: $ make serve docker build -t traefik-mesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /home/user/traefik-mesh/docs:/mkdocs -p 8000:8000 traefik-mesh-docs mkdocs serve # [\u2026] INFO - Building documentation... INFO - Cleaning site directory [I 200408 14:36:33 server:296] Serving on http://0.0.0.0:8000 [I 200408 14:36:33 handlers:62] Start watching changes [I 200408 14:36:33 handlers:64] Start detecting changes Note By default, the local documentation server listens on http://127.0.0.1:8000 . To build the documentation without serving it locally, use the build target.","title":"With Docker and make"},{"location":"contributing/documentation/#with-mkdocs","text":"First, make sure you have python and pip installed. MkDocs supports python versions 2.7.9+ , 3.4 , 3.5 , 3.6 and 3.7 . $ python --version Python 2.7.14 $ pip --version pip 19.3.1 from /usr/local/lib/python2.7/site-packages/pip (python 2.7) Then, install MkDocs with pip . pip install --user -r requirements.txt To build the documentation and serve it locally, run mkdocs serve from the root directory. This starts a local server, and exposes the documentation on http://127.0.0.1:8000 : $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes","title":"With MkDocs"},{"location":"contributing/documentation/#checking","text":"To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the verify target. If you've made changes to the documentation, it's safer to clean it before verifying it. $ make clean verify docker build -t traefik-mesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /home/user/traefik-mesh/docs:/mkdocs -p 8000:8000 traefik-mesh-docs sh -c \"mkdocs build && chown -R 501:20 ./site\" === Checking HTML content... # [\u2026] Disabling Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : $ DOCS_VERIFY_SKIP=true make verify # [\u2026] DOCS_VERIFY_SKIP is true: no verification done.","title":"Checking"},{"location":"contributing/maintainers/","text":"Maintainers \u00b6 Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Micha\u00ebl Matur @mmatur Landry Benguigui @LandryBe Harold Ozouf @jspdown Julien Levesy @jlevesy Brendan Le Glaunec @Ullaakut Kevin Pollet @kevinpollet","title":"Maintainers"},{"location":"contributing/maintainers/#maintainers","text":"Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Micha\u00ebl Matur @mmatur Landry Benguigui @LandryBe Harold Ozouf @jspdown Julien Levesy @jlevesy Brendan Le Glaunec @Ullaakut Kevin Pollet @kevinpollet","title":"Maintainers"},{"location":"contributing/submitting-issues/","text":"Submitting Issues \u00b6 We use the GitHub issue tracker to keep track of Traefik Mesh issues. The process of sorting and checking the issues requires a lot of work. To save us some time and get quicker feedback, be sure to follow the guidelines below. Getting Help The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, use the Traefik Mesh community forum . Issue Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the issue template as much as possible. Explain in which context you encountered the issue. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). Feature Request \u00b6 Remember, when asking for new features, they must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do your best to explain what you're looking for, and why it would improve Traefik Mesh for everyone. International English \u00b6 Traefik Mesh maintainers/users are not all native English speakers, so if you sometimes feel that some messages sound rude, remember that it's probably a language barrier problem from someone willing to help you.","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#submitting-issues","text":"We use the GitHub issue tracker to keep track of Traefik Mesh issues. The process of sorting and checking the issues requires a lot of work. To save us some time and get quicker feedback, be sure to follow the guidelines below. Getting Help The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, use the Traefik Mesh community forum .","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#issue-title","text":"The title must be short and descriptive. (~60 characters)","title":"Issue Title"},{"location":"contributing/submitting-issues/#description","text":"Follow the issue template as much as possible. Explain in which context you encountered the issue. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-issues/#feature-request","text":"Remember, when asking for new features, they must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do your best to explain what you're looking for, and why it would improve Traefik Mesh for everyone.","title":"Feature Request"},{"location":"contributing/submitting-issues/#international-english","text":"Traefik Mesh maintainers/users are not all native English speakers, so if you sometimes feel that some messages sound rude, remember that it's probably a language barrier problem from someone willing to help you.","title":"International English"},{"location":"contributing/submitting-pull-requests/","text":"Submitting Pull Requests \u00b6 So you've decided to improve Traefik Mesh? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go through the classic pitfalls to make sure everything is right. Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). Content \u00b6 Make it small. Each PR should be linked to an issue. One feature per PR. PRs should be standalone (they should not depend on an upcoming PR). Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Commits should be split properly (in order to guide reviewers through the code). Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (don't amend/squash existing ones unless the PR is trivial).","title":"Submitting Pull Requests"},{"location":"contributing/submitting-pull-requests/#submitting-pull-requests","text":"So you've decided to improve Traefik Mesh? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go through the classic pitfalls to make sure everything is right.","title":"Submitting Pull Requests"},{"location":"contributing/submitting-pull-requests/#title","text":"The title must be short and descriptive. (~60 characters)","title":"Title"},{"location":"contributing/submitting-pull-requests/#description","text":"Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-pull-requests/#content","text":"Make it small. Each PR should be linked to an issue. One feature per PR. PRs should be standalone (they should not depend on an upcoming PR). Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Commits should be split properly (in order to guide reviewers through the code). Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (don't amend/squash existing ones unless the PR is trivial).","title":"Content"},{"location":"contributing/thank-you/","text":"Thank You! \u00b6 Traefik Mesh is an open-source project , your feedback and contributions are needed and always welcome! Where to Go Next? If you want to: Propose and idea, request a feature a report a bug, read the page Submitting Issues . Discover how to make an efficient contribution, read the page Submitting Pull Requests . Learn how to build and test Traefik Mesh, the page Building and Testing is for you. Contribute to the documentation, read the related page Documentation .","title":"Thank You!"},{"location":"contributing/thank-you/#thank-you","text":"Traefik Mesh is an open-source project , your feedback and contributions are needed and always welcome! Where to Go Next? If you want to: Propose and idea, request a feature a report a bug, read the page Submitting Issues . Discover how to make an efficient contribution, read the page Submitting Pull Requests . Learn how to build and test Traefik Mesh, the page Building and Testing is for you. Contribute to the documentation, read the related page Documentation .","title":"Thank You!"},{"location":"migration/helm-chart/","text":"Migrations \u00b6 Helm Chart v2.1 to v3.0 \u00b6 Traefik Mesh renaming \u00b6 All existing resources have been renamed and prefixed by traefik-mesh . For example, the maesh-controller resource has been renamed to traefik-mesh-controller . Mesh Property Name \u00b6 Inside the Traefik Mesh helm chart, the mesh property has been renamed to proxy . Image version \u00b6 Since version v1.4 , Traefik Mesh uses plain Traefik Docker image for proxies. Therefore, to change the image version used for the controller, or the proxies you should use the controller.image and proxy.image options. Default Mode \u00b6 The mesh.defaultMode option has been removed. You should use the new defaultMode option to configure the default traffic mode. v2.0 to v2.1 \u00b6 Default Mode \u00b6 The mesh.defaultMode option has been deprecated and will be removed in a future major release. You should use the new defaultMode option to configure the default traffic mode. Prometheus and Grafana services \u00b6 Prior to version v2.1 , when the Metrics chart is deployed, Prometheus and Grafana services are exposed by default through a NodePort . For security reasons, those services are not exposed by default anymore. To expose them you should use the new prometheus.service and grafana.service options, more details in the corresponding values.yaml . v1.x to v2.0 \u00b6 Image version \u00b6 Since version v1.2 , Traefik is used as a library. Therefore, the controller.image and mesh.image options have been removed. You should use the new image option as described in the documentation . Log Level \u00b6 The controller.logging.debug and mesh.logging options have been removed. You should use the new controller.logLevel and mesh.logLevel options to configure the logging level for the controller and proxies. SMI Mode \u00b6 The smi.enable option has been deprecated and removed. You should use the new and backward compatible ACL mode option as described in the documentation .","title":"Helm Chart"},{"location":"migration/helm-chart/#migrations","text":"Helm Chart","title":"Migrations"},{"location":"migration/helm-chart/#v21-to-v30","text":"","title":"v2.1 to v3.0"},{"location":"migration/helm-chart/#traefik-mesh-renaming","text":"All existing resources have been renamed and prefixed by traefik-mesh . For example, the maesh-controller resource has been renamed to traefik-mesh-controller .","title":"Traefik Mesh renaming"},{"location":"migration/helm-chart/#mesh-property-name","text":"Inside the Traefik Mesh helm chart, the mesh property has been renamed to proxy .","title":"Mesh Property Name"},{"location":"migration/helm-chart/#image-version","text":"Since version v1.4 , Traefik Mesh uses plain Traefik Docker image for proxies. Therefore, to change the image version used for the controller, or the proxies you should use the controller.image and proxy.image options.","title":"Image version"},{"location":"migration/helm-chart/#default-mode","text":"The mesh.defaultMode option has been removed. You should use the new defaultMode option to configure the default traffic mode.","title":"Default Mode"},{"location":"migration/helm-chart/#v20-to-v21","text":"","title":"v2.0 to v2.1"},{"location":"migration/helm-chart/#default-mode_1","text":"The mesh.defaultMode option has been deprecated and will be removed in a future major release. You should use the new defaultMode option to configure the default traffic mode.","title":"Default Mode"},{"location":"migration/helm-chart/#prometheus-and-grafana-services","text":"Prior to version v2.1 , when the Metrics chart is deployed, Prometheus and Grafana services are exposed by default through a NodePort . For security reasons, those services are not exposed by default anymore. To expose them you should use the new prometheus.service and grafana.service options, more details in the corresponding values.yaml .","title":"Prometheus and Grafana services"},{"location":"migration/helm-chart/#v1x-to-v20","text":"","title":"v1.x to v2.0"},{"location":"migration/helm-chart/#image-version_1","text":"Since version v1.2 , Traefik is used as a library. Therefore, the controller.image and mesh.image options have been removed. You should use the new image option as described in the documentation .","title":"Image version"},{"location":"migration/helm-chart/#log-level","text":"The controller.logging.debug and mesh.logging options have been removed. You should use the new controller.logLevel and mesh.logLevel options to configure the logging level for the controller and proxies.","title":"Log Level"},{"location":"migration/helm-chart/#smi-mode","text":"The smi.enable option has been deprecated and removed. You should use the new and backward compatible ACL mode option as described in the documentation .","title":"SMI Mode"},{"location":"migration/traefik-mesh-v1/","text":"Minor Migrations \u00b6 Traefik Mesh v1 Traefik Mesh v1.4 \u00b6 Maesh has been renamed to Traefik Mesh in an effort to rename all of our products and make them look closer. Through this renaming process, a couple of things changed which might be worth mentioning for a migration process. All areas that changed are mentioned below with the appropriate actions needed to do. Everything called Maesh references to v1.3 , while Traefik Mesh refers to v1.4 . Environment Variable Prefix \u00b6 Prior to Traefik Mesh, environment variables were prefixed with MAESH_ . Now they're prefixed with TRAEFIK_MESH_ and the MAESH_ prefix is deprecated. You need to decide on either using MAESH_ or TRAEFIK_MESH_ as mixing both will result in an error. Configuration File Name \u00b6 The default configuration file name is changed from maesh to traefik-mesh as well. DNS Name \u00b6 The well known internal DNS name, to opt in into the usage of Maesh was .maesh . Now, with the rebranding process this has been changed to traefik.mesh and thus, you now need to use the DNS name of servicename.servicenamespace.traefik.maesh to opt-in into the usage of Traefik Mesh. The old name .maesh , is deprecated and will be removed eventually. Docker Image Name \u00b6 As part of the process, the docker-image has been moved from containous/maesh to traefik/mesh . The old image will not be updated anymore and traefik/mesh starts with v1.4.0 . Binary \u00b6 The new binary name is traefik-mesh , rather than maesh before. However, as Traefik Mesh is running inside k8s this change should not be critical as it's hidden by the docker-image name. Annotations \u00b6 As part of the rebranding process, the annotation prefix has changed. The annotation prefix maesh.containo.us/ has been deprecated in favour of mesh.traefik.io . v1.1 to v1.2 \u00b6 Debug \u00b6 The --debug CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new --logLevel flag with debug as value. SMI Mode \u00b6 The --smi CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new and backward compatible --acl flag.","title":"Traefik Mesh v1"},{"location":"migration/traefik-mesh-v1/#minor-migrations","text":"Traefik Mesh v1","title":"Minor Migrations"},{"location":"migration/traefik-mesh-v1/#traefik-mesh-v14","text":"Maesh has been renamed to Traefik Mesh in an effort to rename all of our products and make them look closer. Through this renaming process, a couple of things changed which might be worth mentioning for a migration process. All areas that changed are mentioned below with the appropriate actions needed to do. Everything called Maesh references to v1.3 , while Traefik Mesh refers to v1.4 .","title":"Traefik Mesh v1.4"},{"location":"migration/traefik-mesh-v1/#environment-variable-prefix","text":"Prior to Traefik Mesh, environment variables were prefixed with MAESH_ . Now they're prefixed with TRAEFIK_MESH_ and the MAESH_ prefix is deprecated. You need to decide on either using MAESH_ or TRAEFIK_MESH_ as mixing both will result in an error.","title":"Environment Variable Prefix"},{"location":"migration/traefik-mesh-v1/#configuration-file-name","text":"The default configuration file name is changed from maesh to traefik-mesh as well.","title":"Configuration File Name"},{"location":"migration/traefik-mesh-v1/#dns-name","text":"The well known internal DNS name, to opt in into the usage of Maesh was .maesh . Now, with the rebranding process this has been changed to traefik.mesh and thus, you now need to use the DNS name of servicename.servicenamespace.traefik.maesh to opt-in into the usage of Traefik Mesh. The old name .maesh , is deprecated and will be removed eventually.","title":"DNS Name"},{"location":"migration/traefik-mesh-v1/#docker-image-name","text":"As part of the process, the docker-image has been moved from containous/maesh to traefik/mesh . The old image will not be updated anymore and traefik/mesh starts with v1.4.0 .","title":"Docker Image Name"},{"location":"migration/traefik-mesh-v1/#binary","text":"The new binary name is traefik-mesh , rather than maesh before. However, as Traefik Mesh is running inside k8s this change should not be critical as it's hidden by the docker-image name.","title":"Binary"},{"location":"migration/traefik-mesh-v1/#annotations","text":"As part of the rebranding process, the annotation prefix has changed. The annotation prefix maesh.containo.us/ has been deprecated in favour of mesh.traefik.io .","title":"Annotations"},{"location":"migration/traefik-mesh-v1/#v11-to-v12","text":"","title":"v1.1 to v1.2"},{"location":"migration/traefik-mesh-v1/#debug","text":"The --debug CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new --logLevel flag with debug as value.","title":"Debug"},{"location":"migration/traefik-mesh-v1/#smi-mode","text":"The --smi CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new and backward compatible --acl flag.","title":"SMI Mode"}]}