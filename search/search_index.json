{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Maesh: Simpler Service Mesh \u00b6 Maesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Maesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh. Non-Invasive Service Mesh \u00b6 Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required. Prerequisites \u00b6 To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v2 with a working tiller service account","title":"Welcome"},{"location":"#maesh-simpler-service-mesh","text":"Maesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Maesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.","title":"Maesh: Simpler Service Mesh"},{"location":"#non-invasive-service-mesh","text":"Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.","title":"Non-Invasive Service Mesh"},{"location":"#prerequisites","text":"To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v2 with a working tiller service account","title":"Prerequisites"},{"location":"api/","text":"API \u00b6 Maesh includes a built-in API that can be used for debugging purposes. This can be useful when Maesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths: /api/configuration/current \u00b6 This endpoint provides raw json of the current configuration built by the controller. Note This may change each request, as it is a live data structure. /api/status/nodes \u00b6 This endpoint provides a json array containing some details about the readiness of the Maesh nodes visible by the controller This endpoint will still return a 200 if there are no visible nodes. /api/status/node/{maesh-pod-name}/configuration \u00b6 This endpoint provides raw json of the current configuration on the Maesh node with the pod name given in {maesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller. /api/status/readiness \u00b6 This endpoint returns a 200 response if the controller successfully deployed a configuration to all Maesh nodes, and Maesh is ready for use. Otherwise, it will return a 500. /api/log/deployment \u00b6 This endpoint provides a json array containing details about configuration deployments made by the controller. This array is currently capped at 1000 entries to avoid memory issues. If this is not enough, please open a github issue and we will look into updating this to be configurable.","title":"API"},{"location":"api/#api","text":"Maesh includes a built-in API that can be used for debugging purposes. This can be useful when Maesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths:","title":"API"},{"location":"api/#apiconfigurationcurrent","text":"This endpoint provides raw json of the current configuration built by the controller. Note This may change each request, as it is a live data structure.","title":"/api/configuration/current"},{"location":"api/#apistatusnodes","text":"This endpoint provides a json array containing some details about the readiness of the Maesh nodes visible by the controller This endpoint will still return a 200 if there are no visible nodes.","title":"/api/status/nodes"},{"location":"api/#apistatusnodemaesh-pod-nameconfiguration","text":"This endpoint provides raw json of the current configuration on the Maesh node with the pod name given in {maesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller.","title":"/api/status/node/{maesh-pod-name}/configuration"},{"location":"api/#apistatusreadiness","text":"This endpoint returns a 200 response if the controller successfully deployed a configuration to all Maesh nodes, and Maesh is ready for use. Otherwise, it will return a 500.","title":"/api/status/readiness"},{"location":"api/#apilogdeployment","text":"This endpoint provides a json array containing details about configuration deployments made by the controller. This array is currently capped at 1000 entries to avoid memory issues. If this is not enough, please open a github issue and we will look into updating this to be configurable.","title":"/api/log/deployment"},{"location":"configuration/","text":"Configuration \u00b6 The configuration for maesh is broken into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the maesh service mesh is installed, and is configured via the values.yaml file in the helm install. Static configuration \u00b6 The maesh image version can be manually defined if needed, as can the version for the Traefik CE mesh nodes. Debug logging can be globally enabled. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Service Mesh Interface (SMI) mode can be enabled. This configures maesh to run in SMI mode, where access and routes are explicitly enabled. Note: By default, all routes and access is denied. Please see the SMI Specification for more information Dynamic configuration \u00b6 Traffic type \u00b6 Annotations on services are the main way to configure maesh behavior. The service mode can be enabled by using the following annotation: maesh.containo.us/traffic-type: \"http\" This annotation can be set to either http or tcp , and will specify the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration. Scheme \u00b6 The scheme used to define custom scheme for request: maesh.containo.us/scheme: \"h2c\" This annotation can be set to either http or h2c and is available for maesh.containo.us/traffic-type: \"http\" . Retry \u00b6 Retries can be enabled by using the following annotation: maesh.containo.us/retry-attempts: \"2\" This annotation sets the number of retry attempts that maesh will make if a network error occurrs. Please note that this value is a string, and needs to be quoted. Circuit breaker \u00b6 Circuit breaker can be enabled by using the following annotation: maesh.containo.us/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here Rate Limit \u00b6 Rate limiting can be enabled by using the following annotations: maesh.containo.us/ratelimit-average: \"100\" maesh.containo.us/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here","title":"Configuration"},{"location":"configuration/#configuration","text":"The configuration for maesh is broken into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the maesh service mesh is installed, and is configured via the values.yaml file in the helm install.","title":"Configuration"},{"location":"configuration/#static-configuration","text":"The maesh image version can be manually defined if needed, as can the version for the Traefik CE mesh nodes. Debug logging can be globally enabled. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Service Mesh Interface (SMI) mode can be enabled. This configures maesh to run in SMI mode, where access and routes are explicitly enabled. Note: By default, all routes and access is denied. Please see the SMI Specification for more information","title":"Static configuration"},{"location":"configuration/#dynamic-configuration","text":"","title":"Dynamic configuration"},{"location":"configuration/#traffic-type","text":"Annotations on services are the main way to configure maesh behavior. The service mode can be enabled by using the following annotation: maesh.containo.us/traffic-type: \"http\" This annotation can be set to either http or tcp , and will specify the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration.","title":"Traffic type"},{"location":"configuration/#scheme","text":"The scheme used to define custom scheme for request: maesh.containo.us/scheme: \"h2c\" This annotation can be set to either http or h2c and is available for maesh.containo.us/traffic-type: \"http\" .","title":"Scheme"},{"location":"configuration/#retry","text":"Retries can be enabled by using the following annotation: maesh.containo.us/retry-attempts: \"2\" This annotation sets the number of retry attempts that maesh will make if a network error occurrs. Please note that this value is a string, and needs to be quoted.","title":"Retry"},{"location":"configuration/#circuit-breaker","text":"Circuit breaker can be enabled by using the following annotation: maesh.containo.us/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here","title":"Circuit breaker"},{"location":"configuration/#rate-limit","text":"Rate limiting can be enabled by using the following annotations: maesh.containo.us/ratelimit-average: \"100\" maesh.containo.us/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here","title":"Rate Limit"},{"location":"examples/","text":"Examples \u00b6 Here are some examples on how to easily deploy Maesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Maesh Simple Example \u00b6 Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml --- apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: containous/whoami:v1.4.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: containous/whoamitcp:latest imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Maesh by following this documentation on your cluster. Since Maesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Maesh since no X-Forwarded-For header should be added. Now, in order to configure Maesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have maesh.containo.us/traffic-type: \"http\" and the TCP service, maesh.containo.us/traffic-type: \"tcp\" . --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"http\" maesh.containo.us/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Maesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.maesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6","title":"Examples"},{"location":"examples/#examples","text":"Here are some examples on how to easily deploy Maesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Maesh","title":"Examples"},{"location":"examples/#simple-example","text":"Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml --- apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: containous/whoami:v1.4.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: containous/whoamitcp:latest imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Maesh by following this documentation on your cluster. Since Maesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Maesh since no X-Forwarded-For header should be added. Now, in order to configure Maesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have maesh.containo.us/traffic-type: \"http\" and the TCP service, maesh.containo.us/traffic-type: \"tcp\" . --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"http\" maesh.containo.us/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Maesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.maesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6","title":"Simple Example"},{"location":"install/","text":"Installation \u00b6 To install maesh, the installation method is quite simple: helm repo add maesh https://containous.github.io/maesh/charts helm repo update Install maesh helm chart: helm install --name=maesh --namespace=maesh maesh/maesh Install from source \u00b6 To build the image locally, run: make to build the binary and build/tag the local image. Deploy helm chart \u00b6 To deploy the helm chart, run: helm install helm/chart/maesh --namespace maesh --set controller.image.pullPolicy=IfNotPresent --set controller.image.tag=latest KubeDNS support \u00b6 Maesh can support KubeDNS helm install --name=maesh --namespace=maesh maesh/maesh --set kubedns=true With this parameter Maesh will install a CoreDNS as a daemonset. KubeDNS will be patched with stubDomains Custom cluster domain \u00b6 If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install --name=maesh --namespace=maesh maesh/maesh --set clusterDomain=my.custom.domain.com Installation namespace \u00b6 Maesh does not need to be installed into the maesh namespace, but it does need to be installed into its own namespace, separate from user namespaces. Verify your installation \u00b6 You can check that Maesh has been installed properly by running the following command: Command kubectl get all -n maesh Expected Output NAME READY STATUS RESTARTS AGE pod/maesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/maesh-mesh-w62z5 1/1 Running 0 11s pod/maesh-mesh-zjlpf 1/1 Running 0 11s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/maesh-mesh-api ClusterIP 100.69.177.254 <none> 8080/TCP 29s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/maesh-mesh 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/maesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/maesh-controller-676fb86b89 1 1 0 28s Usage \u00b6 To use maesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.maesh . This will access the maesh service mesh, and will allow you to route requests through maesh. By default, maesh is opt-in, meaning you have to use the maesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Installation"},{"location":"install/#installation","text":"To install maesh, the installation method is quite simple: helm repo add maesh https://containous.github.io/maesh/charts helm repo update Install maesh helm chart: helm install --name=maesh --namespace=maesh maesh/maesh","title":"Installation"},{"location":"install/#install-from-source","text":"To build the image locally, run: make to build the binary and build/tag the local image.","title":"Install from source"},{"location":"install/#deploy-helm-chart","text":"To deploy the helm chart, run: helm install helm/chart/maesh --namespace maesh --set controller.image.pullPolicy=IfNotPresent --set controller.image.tag=latest","title":"Deploy helm chart"},{"location":"install/#kubedns-support","text":"Maesh can support KubeDNS helm install --name=maesh --namespace=maesh maesh/maesh --set kubedns=true With this parameter Maesh will install a CoreDNS as a daemonset. KubeDNS will be patched with stubDomains","title":"KubeDNS support"},{"location":"install/#custom-cluster-domain","text":"If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install --name=maesh --namespace=maesh maesh/maesh --set clusterDomain=my.custom.domain.com","title":"Custom cluster domain"},{"location":"install/#installation-namespace","text":"Maesh does not need to be installed into the maesh namespace, but it does need to be installed into its own namespace, separate from user namespaces.","title":"Installation namespace"},{"location":"install/#verify-your-installation","text":"You can check that Maesh has been installed properly by running the following command: Command kubectl get all -n maesh Expected Output NAME READY STATUS RESTARTS AGE pod/maesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/maesh-mesh-w62z5 1/1 Running 0 11s pod/maesh-mesh-zjlpf 1/1 Running 0 11s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/maesh-mesh-api ClusterIP 100.69.177.254 <none> 8080/TCP 29s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/maesh-mesh 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/maesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/maesh-controller-676fb86b89 1 1 0 28s","title":"Verify your installation"},{"location":"install/#usage","text":"To use maesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.maesh . This will access the maesh service mesh, and will allow you to route requests through maesh. By default, maesh is opt-in, meaning you have to use the maesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Usage"},{"location":"quickstart/","text":"Quickstart \u00b6 Maesh can be installed in your cluster without affecting any running services. It will safely install itself via the helm chart, and will be ready for use immediately after. It can be installed by running: helm repo add maesh https://containous.github.io/maesh/charts helm repo update helm install --name=maesh --namespace=maesh maesh/maesh Prerequisites \u00b6 Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v2 with a working tiller service account RBAC \u00b6 Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions. kubeadm \u00b6 If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system Assuming tiller is deployed in your kube-system namespace, this will give it very open permissions. Installation Examples \u00b6 See the examples page to see how to easily deploy Maesh and configure your services to use it.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Maesh can be installed in your cluster without affecting any running services. It will safely install itself via the helm chart, and will be ready for use immediately after. It can be installed by running: helm repo add maesh https://containous.github.io/maesh/charts helm repo update helm install --name=maesh --namespace=maesh maesh/maesh","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v2 with a working tiller service account","title":"Prerequisites"},{"location":"quickstart/#rbac","text":"Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions.","title":"RBAC"},{"location":"quickstart/#kubeadm","text":"If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system Assuming tiller is deployed in your kube-system namespace, this will give it very open permissions.","title":"kubeadm"},{"location":"quickstart/#installation-examples","text":"See the examples page to see how to easily deploy Maesh and configure your services to use it.","title":"Installation Examples"}]}